---
description: Autonomous execution mode for zero-to-one development
alwaysApply: false
---

# Autonomous Execution Mode

## Purpose

This file defines rules for autonomous batch execution of development tasks, enabling the agent to complete entire phases without user intervention between tasks. This mode is activated by commands like `/one-shot` and `/batch`.

---

## Execution Modes

### Manual Mode (Default)
- Agent waits for approval after each task
- User reviews plans before implementation
- Explicit commit approval required
- Activated by: `/plan`, `/implement`, individual task commands

### Autonomous Mode
- Agent executes multiple tasks sequentially
- Plans are created silently (not shown to user)
- Commits proceed through approval workflow automatically
- Only stops for errors, failures, or phase completion
- Activated by: `/one-shot Phase N`, `/batch [tasks]`

---

## Autonomous Mode Behavior

### Core Principle
**In autonomous mode, the agent operates continuously without user intervention EXCEPT for errors, failures, or explicit ambiguities.**

### When to Pause in Autonomous Mode

**MUST PAUSE for:**
- Test failures after 3 retry attempts
- Task requirements are ambiguous or unclear
- Pre-commit hook failures (non-review errors like linting, type errors)
- Critical errors that cannot be auto-resolved
- Phase completion (for summary and review)

**DO NOT PAUSE for:**
- Task completion (continue to next task immediately)
- Successful commits (continue to next task immediately)
- Memory bank updates (do automatically)
- Task tracker updates (do automatically)
- Claude code review iterations (handle automatically via approval workflow)

### Task Execution Flow in Autonomous Mode

```
For each task in queue:
  1. Read context (memory-bank, task details, rules)
  2. Plan implementation (SILENTLY - do not show to user)
  3. Write tests first (TDD)
  4. Implement to pass tests
  5. Run tests (retry up to 3 times if failures)
  6. Update documentation (memory bank, task tracker)
  7. Commit via approval workflow (see below)
  8. IMMEDIATELY continue to next task (DO NOT PAUSE)

After all tasks complete:
  9. Update memory bank (if phase complete or 90% context)
  10. Update task tracker
  11. Generate phase summary (if phase complete)
  12. Report completion and pause
```

---

## Commit Approval Workflow

### Overview

All commits go through the pre-commit hook which triggers Claude code review. The hook is interactive and will always block the first commit attempt, returning control to the Cursor agent for review and iteration.

### Claude Review Context (What Gets Sent)

The pre-commit hook sends a selective set of context files to Claude for an informed but unbiased review:

**Essential Context (always included):**
- `_docs/architecture.md` - Technical architecture and patterns
- `_docs/best-practices.md` - Project coding standards
- `.cursor/rules/base.mdc` - Core development principles

**Conditional Context (included if relevant):**
- `memory-bank/activeContext.md` - If changes relate to current work focus
- `memory-bank/systemPatterns.md` - If changes involve architectural modifications

**Task Context:**
- If commit message contains `Task: X.Y`, that task's context is included

**Excluded (to avoid bias):**
- `memory-bank/progress.md` - Avoids completion pressure bias
- `_docs/task-list.md` - Avoids scope creep suggestions
- Personal notes or summaries

This selective approach ensures Claude has enough context to provide informed feedback without being biased toward completion or scope expansion.

### The Approval Cycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Agent: git commit -m "message"                          â”‚
â”‚ â†“                                                        â”‚
â”‚ Pre-commit Hook: Triggers Claude review (INTERACTIVE)   â”‚
â”‚ â†“                                                        â”‚
â”‚ Claude: Reviews code, provides feedback                 â”‚
â”‚ â†“                                                        â”‚
â”‚ Hook: Prompts user (y/n/v) - BLOCKS execution          â”‚
â”‚ â†“                                                        â”‚
â”‚ Returns to Agent with review feedback                   â”‚
â”‚ â†“                                                        â”‚
â”‚ Agent: Analyzes Claude's review                         â”‚
â”‚ â†“                                                        â”‚
â”‚ IF: Approval + no changes needed                        â”‚
â”‚   â†’ Agent: git commit -m "same message"                 â”‚
â”‚         with AUTO_ACCEPT=true                           â”‚
â”‚   â†’ Commit succeeds âœ…                                   â”‚
â”‚                                                          â”‚
â”‚ IF: Approval + recommendations                          â”‚
â”‚   â†’ Agent: Decides if recommendations are significant   â”‚
â”‚   â†’ IF significant: implement â†’ REPEAT cycle            â”‚
â”‚   â†’ IF not significant: AUTO_ACCEPT=true â†’ Commit âœ…    â”‚
â”‚                                                          â”‚
â”‚ IF: Issues found (bugs, security, etc.)                â”‚
â”‚   â†’ Agent: Fix issues â†’ REPEAT cycle                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Commit Approval Decision Logic

When Claude provides review feedback, the agent must:

#### **Scenario 1: Approval with "No Issues" or "Ready to Commit"**
```
Claude says: "âœ… APPROVED - Code looks good, no issues found"

Agent action:
â†’ IMMEDIATELY resubmit with AUTO_ACCEPT=true
â†’ Use EXACT same commit message
â†’ DO NOT make any changes
```

#### **Scenario 2: Approval with Non-Blocking Recommendations**
```
Claude says: "âœ… APPROVED - Consider adding JSDoc comments for public methods"

Agent decision tree:
1. Are recommendations significant (improve quality/security/performance)?
   YES â†’ Implement recommendations â†’ Request NEW approval
   NO â†’ Proceed with AUTO_ACCEPT=true

2. Are recommendations in scope for this task?
   YES â†’ Consider implementing
   NO â†’ Defer (can be separate task)

3. Is there clear reason to defer?
   YES â†’ Proceed with AUTO_ACCEPT=true
   NO â†’ Implement if significant
```

#### **Scenario 3: Issues Found (Bugs, Security, Critical)**
```
Claude says: "âŒ ISSUES FOUND - SQL injection vulnerability in line 42"

Agent action:
â†’ Fix ALL critical issues
â†’ Request NEW approval (DO NOT use AUTO_ACCEPT)
â†’ REPEAT approval cycle
```

#### **Scenario 4: Pre-commit Hook Failure (Non-Review)**
```
Pre-commit hook fails with: "ESLint error: Unused variable 'foo'"

Agent action:
â†’ STOP autonomous execution
â†’ Report error to user
â†’ Wait for manual intervention
â†’ DO NOT attempt AUTO_ACCEPT
```

### AUTO_ACCEPT Usage Rules

#### **ALLOWED to use AUTO_ACCEPT=true when:**
âœ… Claude explicitly approved the commit
âœ… No changes made since approval
âœ… Resubmitting EXACT same commit message
âœ… Agent chose to defer non-blocking recommendations

#### **FORBIDDEN to use AUTO_ACCEPT=true when:**
âŒ No approval received yet
âŒ Any changes made after approval (even minor)
âŒ Pre-commit hook failed for non-review reasons
âŒ Attempting to bypass review process
âŒ Using `-n` or `--no-verify` flags (NEVER allowed)

### Standardized Claude Review Response Format

The pre-commit hook requests Claude to provide reviews in a standardized format. The agent should parse this structured response to make decisions.

**Expected Format:**
```markdown
## CODE REVIEW RESULT

**Status**: [APPROVED / ISSUES FOUND]

### Critical Issues
[None / List of critical issues]

### Non-Blocking Recommendations
[None / List of recommendations]

### Decision Summary
[APPROVED] - Ready to commit [with/without recommendations]
[ISSUES FOUND] - Must fix critical issues before commit
```

### Parsing Claude's Response

**Step 1: Extract Status**

Look for the line: `**Status**: [value]`

- If `APPROVED` â†’ Approval received
- If `ISSUES FOUND` â†’ Critical issues present

**Step 2: Parse Critical Issues**

Check the "Critical Issues" section:
- If says "None" â†’ No critical issues
- If lists issues â†’ Parse each issue (severity, location, description, fix)

**Step 3: Parse Non-Blocking Recommendations**

Check the "Non-Blocking Recommendations" section:
- If says "None" â†’ No recommendations
- If lists recommendations â†’ Parse each (type, suggestion, rationale)

**Step 4: Make Decision**

Based on parsed data:

```
IF Status = "APPROVED" AND Critical Issues = "None"
  â†’ Check Non-Blocking Recommendations
    â†’ IF "None": Use AUTO_ACCEPT=true immediately
    â†’ IF present: Evaluate significance
      â†’ IF significant AND in-scope: Implement â†’ New approval
      â†’ IF not significant OR out-of-scope: Use AUTO_ACCEPT=true

IF Status = "ISSUES FOUND"
  â†’ Fix all critical issues
  â†’ Request NEW approval
  â†’ DO NOT use AUTO_ACCEPT
```

### Detecting Commit Approval (Legacy Format)

If Claude does not use the standardized format (fallback), look for these signals:

**Approval Indicators:**
- "APPROVED" (case-insensitive)
- "Ready to commit"
- "No issues found"
- "LGTM" (Looks Good To Me)
- "Looks good"

**NOT Approval:**
- "Consider..."
- "Suggest..."
- "Could improve..."
- "Minor issue..." (WITHOUT explicit approval)

**Issues Found (NOT Approval):**
- "ISSUES FOUND"
- "Must fix", "Should fix", "Required"
- "Security vulnerability"
- "Bug", "Error", "Problem" (in context of critical issues)

### Example Approval Flow with Standardized Format

**Iteration 1: Issues Found**
```bash
$ git commit -m "feat: implement user authentication"
```

Claude responds:
```markdown
## CODE REVIEW RESULT

**Status**: ISSUES FOUND

### Critical Issues
- Severity: HIGH
  Location: src/auth/login.ts:42
  Description: SQL injection vulnerability in login query
  Fix: Use parameterized queries instead of string concatenation

### Non-Blocking Recommendations
- Type: Quality
  Suggestion: Add JSDoc comments for public API functions
  Rationale: Improves maintainability and IDE autocomplete

### Decision Summary
[ISSUES FOUND] - Must fix critical issues before commit
```

Agent action:
- Parses: Status = "ISSUES FOUND"
- Sees critical issue: SQL injection
- Fixes SQL injection vulnerability
- Requests NEW approval (no AUTO_ACCEPT)

**Iteration 2: Approval with Recommendations**
```bash
$ git commit -m "feat: implement user authentication"
```

Claude responds:
```markdown
## CODE REVIEW RESULT

**Status**: APPROVED

### Critical Issues
None

### Non-Blocking Recommendations
- Type: Security
  Suggestion: Add rate limiting to login endpoint
  Rationale: Prevents brute force attacks

- Type: Documentation
  Suggestion: Add JSDoc comments for authentication functions
  Rationale: Improves code maintainability

### Decision Summary
[APPROVED] - Ready to commit with recommendations
```

Agent action:
- Parses: Status = "APPROVED", Critical Issues = "None"
- Evaluates recommendations:
  - Rate limiting: Significant security improvement â†’ Implement
  - JSDoc: Quality improvement but not critical â†’ Defer
- Implements rate limiting
- Requests NEW approval (changes made after approval)

**Iteration 3: Approval without Issues**
```bash
$ git commit -m "feat: implement user authentication"
```

Claude responds:
```markdown
## CODE REVIEW RESULT

**Status**: APPROVED

### Critical Issues
None

### Non-Blocking Recommendations
None

### Decision Summary
[APPROVED] - Ready to commit
```

Agent action:
- Parses: Status = "APPROVED", Critical Issues = "None", Recommendations = "None"
- No changes needed
- Uses AUTO_ACCEPT=true immediately

**Final Commit:**
```bash
$ AUTO_ACCEPT=true git commit -m "feat: implement user authentication"
# Bypasses interactive prompt â†’ Commit succeeds âœ…
```

### Handling AUTO_ACCEPT Violations

If the agent incorrectly uses `AUTO_ACCEPT=true`, the pre-commit hook will:
1. **Detect the violation** (wrong usage scenario)
2. **Log it** to `_logs/commit-violations.log` for human review
3. **Block the commit** with clear instructions
4. **Guide the agent** to retry without AUTO_ACCEPT

**Violation Types:**
- `AUTO_ACCEPT_ON_FIRST_ATTEMPT`: Used on first commit without prior approval
- `AUTO_ACCEPT_WITHOUT_APPROVAL`: Used when previous status was not APPROVED
- `AUTO_ACCEPT_WITH_MODIFIED_CONTENT`: Used after changing files post-approval
- `AUTO_ACCEPT_FILE_COUNT_MISMATCH`: Used after adding/removing files post-approval

**Agent Response to Violation:**

When commit fails with "AUTO_ACCEPT VIOLATION DETECTED":

```bash
# Commit attempt failed
$ AUTO_ACCEPT=true git commit -m "feat: add auth"
âš ï¸  AUTO_ACCEPT VIOLATION DETECTED

Violation: AUTO_ACCEPT_ON_FIRST_ATTEMPT
Details: AUTO_ACCEPT=true used on first commit attempt without prior approval

This attempt has been logged to: _logs/commit-violations.log

ğŸ“‹ ACTION REQUIRED:
Retry the commit WITHOUT AUTO_ACCEPT=true:

  git commit -m "feat: add auth"

# Exit code: 1 (failure)
```

**Agent MUST:**
1. **Recognize** the violation (check exit code and output)
2. **Retry** WITHOUT `AUTO_ACCEPT=true`
3. **Go through** normal Claude review cycle
4. **Use** `AUTO_ACCEPT=true` only after receiving approval

**Example Self-Correction:**

```bash
# Attempt 1 (WRONG)
$ AUTO_ACCEPT=true git commit -m "feat: add auth"
# âŒ Violation detected

# Attempt 2 (CORRECT - retry without AUTO_ACCEPT)
$ git commit -m "feat: add auth"
# Claude reviews â†’ APPROVED

# Attempt 3 (NOW VALID)
$ AUTO_ACCEPT=true git commit -m "feat: add auth"
# âœ… Succeeds
```

**Viewing Violations:**

To see logged violations:
```bash
cat _logs/commit-violations.log

# Or use the helper script
./_logs/show-violations.sh
```

**Important:**
- Violations are **logged** (not silently ignored)
- Violations **block the commit** (prevent bad behavior)
- Violations **guide the agent** (provide clear next steps)
- Violations are **human-auditable** (track patterns over time)

---

## Context Window Management

### Monitoring Context Usage

The agent should track token usage throughout execution. When context reaches **90% capacity**:

1. **Pause current task** (finish current operation, don't start new tests/implementation)
2. **Update memory bank** with all recent work
3. **Compact context** using progressive reduction (see below)
4. **Resume current task** from where it paused

### Progressive Context Reduction

When compacting at 90% capacity, remove in this priority order:

#### **Priority 1: Remove Code Snippets**
- Remove large code blocks from earlier tasks
- Keep only file paths and brief descriptions
- Preserve error messages and critical details

#### **Priority 2: Remove Old Task Details**
- Summarize completed tasks (keep only: task ID, status, commit hash)
- Remove implementation details from tasks >2 tasks ago
- Keep current task details intact

#### **Priority 3: Remove Conditional Docs**
- Remove conditional context (if it was included):
  - Recent commit history (if >5 commits loaded)
  - systemPatterns.md (if no architectural changes in progress)
- Keep essential context:
  - activeContext.md (always keep)
  - Current task details (always keep)
  - Architecture.md relevant sections (always keep)

#### **Priority 4: Summarize Memory Bank Entries**
- Create inline summary of older memory bank entries
- Keep most recent "Recent Changes" in activeContext.md
- Remove older "Recent Changes" entries (>1 week old)

### Context Compaction Example

**Before (90% capacity):**
```
Memory Bank: Full activeContext.md, progress.md, systemPatterns.md
Task 1.1: Full implementation details, test code, review iterations
Task 1.2: Full implementation details, test code, review iterations
Task 1.3: [CURRENT] Full details
Architecture: 3 full sections loaded
Commit History: Last 10 commits with diffs
```

**After (reduced to ~60% capacity):**
```
Memory Bank: activeContext.md, progress.md summary
Task 1.1: âœ… Complete - Commit abc123 - DynamoDB client implemented
Task 1.2: âœ… Complete - Commit def456 - Retry logic implemented
Task 1.3: [CURRENT] Full details (preserved)
Architecture: Current relevant section only
Commit History: Removed
```

---

## Task Tracker Status Management

### Five-State System

Autonomous mode uses these task states:

- `[ ]` **Not Started** - Task not yet begun
- `[>]` **In Progress** - Task currently being worked on
- `[x]` **Completed** - Task finished successfully
- `[~]` **Skipped** - Task deferred or not needed
- `[!]` **Failed** - Task failed after 3 retry attempts

### State Transitions in Autonomous Mode

```
[ ] â†’ [>] : Start task
[>] â†’ [x] : Tests pass, commit successful
[>] â†’ [!] : 3 retry attempts exhausted
[!] â†’ [>] : User fixes issue, agent retries (manual restart)
[ ] â†’ [~] : User requests skip, or task no longer needed
```

### Handling Failed Tasks `[!]`

When a task reaches `[!]` status:

1. **Document failure** in memory-bank/progress.md:
   - Error details
   - What was attempted
   - Why retries failed
   - Recommended fix

2. **Update task tracker**:
   - Mark task as `[!]`
   - Add failure note in completion log

3. **HALT execution**:
   - Stop autonomous mode
   - Report failure to user
   - List remaining tasks

4. **Recovery** (when user reruns `/one-shot` or `/batch`):
   - Agent can retry `[!]` tasks automatically
   - Starts fresh (not from saved state)
   - If fails again â†’ mark `[!]` again and halt

---

## Phase Completion Procedures

When all tasks in a phase are complete:

### 1. Update Memory Bank
- Full update of memory-bank/activeContext.md
- Full update of memory-bank/progress.md
- Update memory-bank/systemPatterns.md if architecture changed
- Mark phase complete

### 2. Update Task Tracker
- Mark all phase tasks as `[x]`
- Update phase progress to 100%
- Update overall progress percentage
- Add completion log entry with date

### 3. Generate Phase Summary
- Create summary in `_context-summaries/[DATE]-phase-[N]-[name].md`
- Use format from example: `@_context-summaries/2025-11-11-phase1-services-implementation.md`
- Include:
  - Tasks completed
  - Files changed
  - Key decisions with rationale
  - Non-obvious solutions (if any)
  - Testing approach
  - Blockers resolved
  - Next steps

### 4. Report Completion
```
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
PHASE [N] COMPLETED
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Tasks: [M]/[M] completed successfully
Commits: [M] commits created
Files: [X] files changed
Tests: All passing

Phase Summary: _context-summaries/[DATE]-phase-[N]-[name].md

Next Phase: Phase [N+1] - [Name]

Ready for user review.
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

---

## Error Handling in Autonomous Mode

### Retry Strategy

**Test Failures:**
- Attempt 1: Run tests, analyze failures
- Attempt 2: Fix issues, rerun tests
- Attempt 3: Fix remaining issues, rerun tests
- After 3 attempts: Mark as `[!]`, halt execution

**Pre-commit Hook Failures (Non-Review):**
- Do NOT retry automatically
- Report error to user
- HALT execution
- Wait for manual intervention

**Claude Review Iterations:**
- No retry limit (not a "failure")
- Continue until approval or critical issue
- Implement fixes as needed
- Request new approval after changes

### Halting Conditions

**MUST HALT autonomous execution when:**
- Task fails after 3 retry attempts
- Pre-commit hook failure (linting, type errors)
- Requirements are ambiguous/unclear
- Critical error that cannot be auto-resolved
- Phase completion (for review)

**DO NOT HALT for:**
- Successful task completion
- Claude review iterations
- Memory bank updates
- Minor warnings in tests/linting (if they pass)

---

## Inter-Task Validation

Before proceeding to next task in autonomous mode, verify:

- [ ] All tests passing (including previously passing tests)
- [ ] No uncommitted changes (commit successful)
- [ ] Memory bank updated (if needed)
- [ ] Task tracker updated
- [ ] Git working directory clean
- [ ] No blocking errors in logs

### âš ï¸ CRITICAL: Commit Approval State Reset

**Each new task starts with NO approval.**

When moving from one task to the next:
- âŒ **NEVER** use `AUTO_ACCEPT=true` on the first commit attempt of a new task
- âŒ **NEVER** carry forward approval from previous task
- âœ… **ALWAYS** go through full Claude review cycle for the first commit of each task
- âœ… **ONLY** use `AUTO_ACCEPT=true` after receiving approval for THIS specific task's commit

**Correct Flow Between Tasks:**
```bash
# Task 1: Completed with AUTO_ACCEPT=true after approval âœ…

# Moving to Task 2...
# Approval state: RESET â†’ NO APPROVAL

# Task 2: First commit attempt
git commit -m "feat: task 2"  # âœ… CORRECT - goes through Claude review

# DO NOT DO THIS:
AUTO_ACCEPT=true git commit -m "feat: task 2"  # âŒ WRONG - skips required review
```

If ANY validation fails:
â†’ HALT execution
â†’ Report issue to user
â†’ Wait for resolution

---

## Communication in Autonomous Mode

### Progress Reporting

Show concise progress updates during execution:

```
Starting Task [N] of [M]: [task-id] - [task-name]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Progress: [N]/[M] tasks ([X]%)

[Brief status updates during implementation]

Task [N] COMPLETED âœ…
Commit: [hash] - [message]
Files: [count] changed
Tests: [count] passing

Continuing to next task...
```

### DO NOT Output in Autonomous Mode:
- Detailed plans (plan silently)
- Full code implementations (unless error)
- Step-by-step reasoning (work silently)
- Approval requests between tasks
- Verbose status updates

### DO Output in Autonomous Mode:
- Task start/completion
- Progress indicators
- Error messages
- Critical decisions
- Final summary

---

## Rules Summary

### Autonomous Mode Principles

**1. Continuity**
- Execute tasks continuously without pausing between completions
- Only stop for errors, ambiguity, or phase completion

**2. Silent Planning**
- Create plans internally without showing to user
- Make implementation decisions autonomously
- Follow established patterns from architecture

**3. Smart Commit Approval**
- Handle Claude review iterations automatically
- Implement significant recommendations
- Use AUTO_ACCEPT=true only after approval with no changes
- Never bypass review with --no-verify

**4. Context Management**
- Monitor token usage continuously
- Compact at 90% capacity
- Preserve essential context

**5. Error Recovery**
- Retry tests up to 3 times
- Halt on non-recoverable errors
- Document failures clearly

### Forbidden Actions (NEVER in Autonomous or Manual Mode)

âŒ Use `git commit -n` or `git commit --no-verify`
âŒ Use `git add .` or `git add -A`
âŒ Use `AUTO_ACCEPT=true` without prior approval
âŒ Use `AUTO_ACCEPT=true` after making changes post-approval
âŒ Skip tests to continue execution
âŒ Commit failing code
âŒ Ignore ambiguous requirements
âŒ Continue after 3 failed retry attempts
âŒ Modify files outside task scope

### Safety Guarantees

The autonomous mode maintains these guarantees:

âœ… All code reviewed by Claude before commit
âœ… All tests pass before commit
âœ… No secrets or sensitive data committed
âœ… Memory bank stays current
âœ… Clear audit trail (task tracker, commits, summaries)
âœ… Can resume after interruption
âœ… User can intervene at any time

---

## Integration with Commands

### Commands that Activate Autonomous Mode

- `/one-shot Phase N` - Execute all remaining tasks in phase N
- `/batch [tasks]` - Execute specified tasks autonomously

### Commands that Use Manual Mode

- `/plan` - Plan single task, show to user
- `/implement` - Implement with approval
- `/commit-with-approval` - Manual commit approval
- Individual task commands

---

**Remember**: Autonomous mode is about velocity with safety. The agent moves quickly through tasks but never bypasses quality gates (tests, code review, validation). When in doubt, pause and ask.
